{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://gravity/./src/helpers/connection.ts","webpack://gravity/./src/helpers/pattern.ts","webpack://gravity/./src/helpers/utils.ts","webpack://gravity/./src/helpers/unitMatrix.ts","webpack://gravity/./src/patterns/grassPattern.ts","webpack://gravity/./src/patterns/heavyForrest.ts","webpack://gravity/./src/patterns/lightForrestPattern.ts","webpack://gravity/./src/patterns/nullPattern.ts","webpack://gravity/./src/helpers/patternManager.ts","webpack://gravity/./src/helpers/cell.ts","webpack://gravity/./src/index.ts","webpack://gravity/./src/helpers/grid.ts"],"sourcesContent":["import { IPattern } from \"./pattern\";\r\nimport { IUnitMatrix } from \"./unitMatrix\";\r\n\r\n\r\nexport interface IConnection {\r\n    pattern: IPattern;\r\n    at: IUnitMatrix;\r\n}\r\n\r\nexport class Connection implements IConnection {\r\n    pattern: IPattern;\r\n    at: IUnitMatrix;\r\n    constructor(pattern: IPattern, at: IUnitMatrix) {\r\n        this.pattern = pattern;\r\n        this.at = at;\r\n    }\r\n}","import { Connection, IConnection } from \"./connection\";\r\nimport { IImage } from \"./image\";\r\nimport { Aliases, patternManager } from \"./patternManager\";\r\nimport { Utils } from \"./utils\"\r\n\r\nexport interface IPattern {\r\n    id: string\r\n    alias: Aliases\r\n    texture: IImage\r\n    connectsTo: Array<IConnection>\r\n    setConnections(): void\r\n}\r\nexport abstract class Pattern {\r\n    id: string;\r\n    alias: Aliases;\r\n    texture: IImage;\r\n    connectsTo: Array<IConnection>;\r\n    constructor(texture: IImage, alias: Aliases) {\r\n        this.alias = alias\r\n        this.id = Utils.randID(20);\r\n        this.texture = texture;\r\n        this.connectsTo = []\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n","export class Utils {\r\n    static randID(length: number) {\r\n        var result = '';\r\n        var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\r\n        var charactersLength = characters.length;\r\n        for (var i = 0; i < length; i++) {\r\n            result += characters.charAt(Math.floor(Math.random() *\r\n                charactersLength));\r\n        }\r\n        return result;\r\n    }\r\n}","\r\nexport interface IUnitMatrix {\r\n    north: boolean;\r\n    west: boolean;\r\n    south: boolean;\r\n    east: boolean;\r\n    atSouth: Function;\r\n    atEast: Function;\r\n    atWest: Function;\r\n    atNorth: Function;\r\n    reset: Function;\r\n}\r\nexport class UnitMatrix implements IUnitMatrix {\r\n\r\n    north: boolean = false;\r\n    west: boolean = false;\r\n    south: boolean = false;\r\n    east: boolean = false;\r\n    constructor() { }\r\n    static connect() {\r\n        return new UnitMatrix;\r\n    }\r\n    everywhere = () => {\r\n        return this.atEast().atNorth().atSouth().atWest();\r\n    }\r\n    atSouth = () => {\r\n        this.south = true;\r\n        return this;\r\n    }\r\n    atEast = () => {\r\n        this.east = true;\r\n        return this;\r\n    }\r\n    atWest = () => {\r\n        this.west = true;\r\n        return this;\r\n    }\r\n    atNorth = () => {\r\n        this.north = true;\r\n        return this;\r\n    }\r\n    reset = () => {\r\n        return new UnitMatrix;\r\n    }\r\n    static check(u1: UnitMatrix, u2: UnitMatrix) {\r\n        if ((u1.east && u2.west)    || (u1.west && u2.east)) return true;\r\n        if ((u1.north && u2.south)  || (u1.south && u2.north)) return true;\r\n        return false;\r\n    }\r\n}","import { Connection } from \"../helpers/connection\";\r\nimport { IPattern, Pattern } from \"../helpers/pattern\";\r\nimport { patternManager } from \"../helpers/patternManager\";\r\nimport { UnitMatrix } from \"../helpers/unitMatrix\";\r\n\r\nexport class GrassPattern extends Pattern {\r\n    constructor() {\r\n        super(\"grass.png\",'grass')\r\n    }\r\n    setConnections(): void {\r\n        let allPatterns = patternManager.getPatterns();\r\n        this.connectsTo = [\r\n            new Connection(\r\n                allPatterns.grass,\r\n                UnitMatrix.connect().everywhere()\r\n            ),\r\n            new Connection(\r\n                allPatterns.light_forest,\r\n                UnitMatrix.connect().everywhere()\r\n            ),\r\n        ]\r\n    }\r\n\r\n}\r\n","import { Connection } from \"../helpers/connection\"\r\nimport { IPattern, Pattern } from \"../helpers/pattern\"\r\nimport { patternManager } from \"../helpers/patternManager\";\r\nimport { UnitMatrix } from \"../helpers/unitMatrix\"\r\n\r\nexport class HeavyForestPattern extends Pattern implements IPattern {\r\n    constructor() {\r\n        super(\"heavy-forest.png\", 'heavy_forest')\r\n    }\r\n    setConnections(): void {\r\n        let allPatterns = patternManager.getPatterns();\r\n        this.connectsTo = [\r\n            new Connection(\r\n                allPatterns.heavy_forest,\r\n                UnitMatrix.connect().everywhere()\r\n            ),\r\n            new Connection(\r\n                allPatterns.light_forest,\r\n                UnitMatrix.connect().everywhere()\r\n            ),\r\n        ]\r\n    }\r\n}\r\n","import { Connection } from \"../helpers/connection\"\r\nimport { IPattern, Pattern } from \"../helpers/pattern\"\r\nimport { patternManager } from \"../helpers/patternManager\";\r\nimport { UnitMatrix } from \"../helpers/unitMatrix\"\r\n\r\nexport class LightForestPattern extends Pattern implements IPattern {\r\n    constructor() {\r\n        super(\"light-forest.png\",'light_forest')\r\n\r\n    }\r\n    setConnections(): void {\r\n        let allPatterns = patternManager.getPatterns();\r\n        this.connectsTo = [\r\n            new Connection(\r\n                allPatterns.grass,\r\n                UnitMatrix.connect().everywhere()\r\n            ),\r\n            new Connection(\r\n                allPatterns.light_forest,\r\n                UnitMatrix.connect().everywhere()\r\n            ),\r\n            new Connection(\r\n                allPatterns.heavy_forest,\r\n                UnitMatrix.connect().everywhere()\r\n            )\r\n        ]\r\n    }\r\n}\r\n","import { Connection } from \"../helpers/connection\"\r\nimport { IPattern, Pattern } from \"../helpers/pattern\"\r\nimport { UnitMatrix } from \"../helpers/unitMatrix\"\r\n\r\nexport class NullPattern extends Pattern implements IPattern {\r\n    constructor() {\r\n        super(\"\", 'null')\r\n        this.connectsTo = [\r\n\r\n        ]\r\n    }\r\n    setConnections() {\r\n    }\r\n}\r\n","import { IPattern } from \"./pattern\";\r\nimport { GrassPattern } from \"../patterns/grassPattern\";\r\nimport { HeavyForestPattern } from \"../patterns/heavyForrest\";\r\nimport { LightForestPattern } from \"../patterns/lightForrestPattern\";\r\nimport { NullPattern } from \"../patterns/nullPattern\";\r\ninterface IPatternManager {\r\n    patterns: IPatternDictionary;\r\n}\r\nclass PatternManager implements IPatternManager {\r\n    patterns: IPatternDictionary\r\n    constructor() {\r\n        this.patterns = {\r\n            grass: new GrassPattern,\r\n            light_forest: new LightForestPattern,\r\n            heavy_forest: new HeavyForestPattern,\r\n            'null': new NullPattern\r\n        }\r\n\r\n    }\r\n    public startConnections() {\r\n        for (let prop in this.patterns) {\r\n            this.patterns[prop].setConnections()\r\n        }\r\n    }\r\n    public getPatterns() {\r\n        return this.patterns;\r\n    }\r\n}\r\nlet pm = new PatternManager;\r\nexport const patternManager = pm;\r\nexport type IPatternDictionary = {\r\n    [alias in Aliases]: IPattern;\r\n};\r\nexport type Aliases = \"grass\" | \"light_forest\" | \"heavy_forest\" | \"null\";\r\n","import { GrassPattern } from \"../patterns/grassPattern\";\r\nimport { NullPattern } from \"../patterns/nullPattern\";\r\nimport { IPattern, Pattern, } from \"./pattern\";\r\nimport { Aliases, IPatternDictionary, patternManager } from \"./patternManager\";\r\nimport { UnitMatrix } from \"./unitMatrix\";\r\n\r\nexport interface ICell {\r\n    x: number;\r\n    y: number;\r\n    pattern: IPattern;\r\n    allPatterns: IPatternDictionary;\r\n    neighbors: Array<ICell>\r\n    choosePattern: (p: IPattern) => void;\r\n    setNeighboors: (neighbors: ICell[]) => void\r\n}\r\n\r\nexport class Cell implements ICell {\r\n    x: number;\r\n    y: number;\r\n    allPatterns: IPatternDictionary = patternManager.getPatterns();\r\n    pattern: IPattern = this.allPatterns.null;\r\n    availablePatterns: AvailabilityMap = {};\r\n\r\n    neighbors: Array<ICell> = [];\r\n    constructor(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        for (let alias in this.allPatterns) {\r\n            this.availablePatterns[alias as Aliases] = { pattern: this.allPatterns[alias], available: true }\r\n        }\r\n    }\r\n    setNeighboors(neighboors: Array<ICell>) {\r\n        this.neighbors = neighboors;\r\n    }\r\n\r\n    choosePattern(p: IPattern) {\r\n        for (let neighbor of this.neighbors) {\r\n            if (neighbor.pattern == this.allPatterns.null)\r\n                break;\r\n            for (let connection of neighbor.pattern.connectsTo) {\r\n                if (p.alias == connection.pattern.alias) {\r\n                    \r\n                }\r\n            }\r\n        }\r\n        if (this.availablePatterns[p.alias]!.available)\r\n            this.pattern = this.availablePatterns[p.alias]!.pattern;\r\n        else\r\n            throw Error(\"Pattern not available\")\r\n    };\r\n\r\n}\r\ninterface ICoords {\r\n    x: number,\r\n    y: number\r\n}\r\ntype AvailabilityMap = {\r\n    [alias in Aliases]?: { pattern: IPattern, available: Boolean }\r\n}","import { Grid } from \"./helpers/grid\"\r\nimport { patternManager } from \"./helpers/patternManager\";\r\npatternManager.startConnections();\r\nconsole.log(\"hi\")\r\nlet grid = new Grid(10, 10)\r\ngrid.generateGrid();\r\nconsole.log(grid);","import { Cell, ICell } from \"./cell\";\r\n\r\ninterface IGrid {\r\n    length: number;\r\n    height: number;\r\n    cells: ICell[][];\r\n    propagateToCells: () => void;\r\n    generateGrid: () => void\r\n}\r\nexport class Grid implements IGrid {\r\n    length!: number;\r\n    height!: number;\r\n    cells: ICell[][] = [];\r\n    constructor(length: number, height: number) {\r\n        this.length = length;\r\n        this.height = height;\r\n    }\r\n    propagateToCells = () => { };\r\n    generateGrid = () => {\r\n        for (let i = 0; i < this.length; i++) {\r\n            this.cells[i] = []\r\n            for (let j = 0; j < this.height; j++) {\r\n                this.cells[i][j] = new Cell(i, j);\r\n            }\r\n        }\r\n        for (let i = 0; i < this.length; i++) {\r\n            for (let j = 0; j < this.height; j++) {\r\n                let cellNeighbors = [];\r\n                i - 1 >= 0 &&\r\n                    cellNeighbors.push(this.cells[i - 1][j])\r\n                j - 1 >= 0 &&\r\n                    cellNeighbors.push(this.cells[1][j - 1])\r\n                i + 1 < this.length &&\r\n                    cellNeighbors.push(this.cells[i + 1][j])\r\n                j + 1 < this.length &&\r\n                    cellNeighbors.push(this.cells[i][j + 1])\r\n                this.cells[i][j].setNeighboors(cellNeighbors);\r\n            }\r\n        }\r\n    };\r\n\r\n}"],"names":["Connection","constructor","pattern","at","this","Pattern","texture","alias","id","static","length","result","characters","charactersLength","i","charAt","Math","floor","random","randID","connectsTo","UnitMatrix","north","west","south","east","everywhere","atEast","atNorth","atSouth","atWest","reset","u1","u2","GrassPattern","super","setConnections","allPatterns","patternManager","getPatterns","grass","connect","light_forest","HeavyForestPattern","heavy_forest","LightForestPattern","NullPattern","patterns","startConnections","prop","Cell","x","y","null","availablePatterns","neighbors","available","setNeighboors","neighboors","choosePattern","p","neighbor","connection","Error","console","log","grid","height","cells","propagateToCells","generateGrid","j","cellNeighbors","push"],"sourceRoot":""}